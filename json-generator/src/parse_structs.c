// parse_structs.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "tree_sitter/api.h"
#include "platform/platform.h"
#include "parse_structs.h"
#include "stb_ds.h"

#define STRUCT_PREFIX_LENGTH sizeof("struct ")

// Include the C language header generated by Tree-sitter
extern const TSLanguage *tree_sitter_c();

// Function to load a text file into a const char*
const char *load_text_file(const char *filename)
{
    FILE *file = fopen(filename, "rb"); // Open in binary mode

    if (file == NULL)
    {
        perror("Failed to open file");
        return NULL;
    }

    // Get the file size
    fseek(file, 0, SEEK_END);
    long filesize = ftell(file);
    fseek(file, 0, SEEK_SET);

    // Allocate memory for the file content
    char *buffer = (char *)malloc(filesize + 1);
    
    if (buffer == NULL)
    {
        perror("Failed to allocate memory");
        fclose(file);
        return NULL;
    }

    // Read the file content into the buffer
    size_t read_size = fread(buffer, 1, filesize, file);
    buffer[read_size] = '\0'; // Null-terminate the string

    fclose(file);

    return buffer;
}

const char *get_node_text(TSNode node, const char *source_code)
{
    uint32_t start = ts_node_start_byte(node);
    uint32_t end = ts_node_end_byte(node);
    size_t length = end - start;
    char *text = (char *)malloc(length + 1);
    strncpy(text, source_code + start, length);
    text[length] = '\0';

    return text;
}

typedef void (*TSQueryMatchHandler)(void *, const char *, TSQuery *, TSQueryMatch);

bool run_query_from_file(void *user_data, const char *query_path, const char *source_code, TSNode node, TSQueryMatchHandler handler)
{
    bool match_found = false;

    // Load query string from file named struct.query into var const char *query_str dynamically
    const char *query_str = load_text_file(query_path);

    // Compile the query
    uint32_t error_offset;
    TSQueryError error_type;
    TSQuery *query = ts_query_new(tree_sitter_c(), query_str, strlen(query_str), &error_offset, &error_type);

    if (query == NULL)
    {
        fprintf(stderr, "Failed to compile query: %.*s\nError type: %d at offset: %d\n", (int)strlen(query_str), query_str, error_type, error_offset);

        free((char *)query_str);

        assert(false);
    }

    free((char *)query_str);

    TSQueryCursor *cursor = ts_query_cursor_new();
    ts_query_cursor_exec(cursor, query, node);

    // Iterate over matches
    TSQueryMatch match;
    while (ts_query_cursor_next_match(cursor, &match))
    {
        match_found = true;
        handler(user_data, source_code, query, match);
    }

    // Clean up
    ts_query_cursor_delete(cursor);
    ts_query_delete(query);

    return match_found;
}

TSNode skip_comments(TSNode node)
{
    TSNode curr_node = node;

    const char *type = ts_node_type(curr_node);

    while(strcmp(type, "comment") == 0)
    {
        curr_node = ts_node_next_sibling(curr_node);
        type = ts_node_type(curr_node);
    }

    return curr_node;
}

bool parse_field(TSNode node, const char *source_code, Field *field)
{
    const char *node_type = ts_node_type(node);

    if(strcmp(node_type, "field_declaration") != 0)
    {
        return false;
    }

    TSNode declarator_node = ts_node_child_by_field_name(node, "declarator", 10);
    const char *declarator_type = ts_node_type(declarator_node);

    if(strcmp(declarator_type, "comment") == 0)
    {
        return false;
    }

    TSNode type_node = ts_node_child_by_field_name(node, "type", 4);
    const char *type_type = ts_node_type(type_node);

    const char *type_name = get_node_text(type_node, source_code);
    
    if(strcmp(declarator_type, "pointer_declarator") == 0)
    {
        TSNode declarator_declarator_node = ts_node_child_by_field_name(declarator_node, "declarator", 10);

        if(strcmp(type_name, "char") == 0)
        {
            const char *declarator_declarator_type = ts_node_type(declarator_declarator_node);
            
            if(strcmp(declarator_declarator_type, "field_identifier") == 0)
            {
                field->type_name = type_name;
                field->name = get_node_text(declarator_declarator_node, source_code);
                field->is_string = true;
                field->is_pointer = true;
                field->is_primitive = strcmp(type_type, "primitive_type") == 0;
                field->type = "char *";

                return true;
            }
            else
            {
                free((char *)type_name);
                return false;
            }
        }
        else
        {
            field->name = get_node_text(declarator_declarator_node, source_code);
            field->is_pointer = true;
        }
    }
    else
    {
        field->name = get_node_text(declarator_node, source_code);
        field->is_pointer = false;
    }

    if(strcmp(type_type, "struct_specifier") == 0)
    {
        TSNode type_name_node = ts_node_child_by_field_name(type_node, "name", 4);

        field->type_name = get_node_text(type_name_node, source_code);
    }
    else
    {
        field->type_name = type_name;
    }

    field->type = type_name;
    field->is_string = false;
    field->is_primitive = strcmp(type_type, "primitive_type") == 0;
    
    return true;
}

bool parse_struct(TSNode root_node, const char *source_code, ParsedStructs *parsed_structs, const char *error)
{
    const char *type_name = NULL;
    const char *type = NULL;

    TSNode curr_node = skip_comments(root_node);

    const char *curr_type = ts_node_type(curr_node);

    if(strcmp(curr_type, "type_definition") == 0)
    {
        TSNode declarator_node = ts_node_child_by_field_name(curr_node, "declarator", 10);

        const char *declarator_type = ts_node_type(declarator_node);

        if(strcmp(declarator_type, "type_identifier") != 0)
        {
            sprintf((char *)error, "Invalid type definition: %s", declarator_type);
            return false;
        }

        type_name = get_node_text(declarator_node, source_code);
        type = get_node_text(declarator_node, source_code);

        curr_node = ts_node_child_by_field_name(curr_node, "type", 4);
        curr_type = ts_node_type(curr_node);
    }

    if(strcmp(curr_type, "struct_specifier") == 0)
    {
        if(type_name == NULL)
        {
            TSNode name_node = ts_node_child_by_field_name(curr_node, "name", 4);

            if(ts_node_is_null(name_node))
            {
                error = "Invalid struct definition without name";
                return false;
            }

            type_name = get_node_text(name_node, source_code);
            type = (char *)malloc(strlen(type_name) + STRUCT_PREFIX_LENGTH);
            sprintf((char *)type, "struct %s", type_name);
        }

        TSNode body_node = ts_node_child_by_field_name(curr_node, "body", 4);
        TSNode child_node = ts_node_child(body_node, 0);

        Field *fields = NULL;

        while(!ts_node_is_null(child_node))
        {
            Field field;
            if(parse_field(child_node, source_code, &field))
            {
                arrput(fields, field);
            }

            child_node = ts_node_next_sibling(child_node);
        }

        if(arrlen(fields) == 0)
        {
            error = "Invalid struct definition without fields";
            return false;
        }

        // Check if Struct represents Array
        if(arrlen(fields) == 2)
        {
            Field *items = NULL;
            Field *len = NULL;
            bool has_pointer = false;
            bool has_len = false;
            
            if(fields[0].is_pointer)
            {
                has_pointer = true;
                items = &fields[0];
            }
            else if(fields[1].is_pointer)
            {
                has_pointer = true;
                items = &fields[1];
            }

            if(strcmp(fields[0].type_name, "size_t") == 0)
            {
                has_len = true;
    	        len = &fields[0];
            }
            else if(strcmp(fields[1].type_name, "size_t") == 0)
            {
                has_len = true;
    	        len = &fields[1];
            }

            if(has_pointer && has_len)
            {
                items->is_items = true;
                len->is_len = true;

                TypeStruct array_struct = {
                    .fields = fields,
                    .type = type,
                    .type_name = type_name
                };

                TypeData type_data = {
                    .type_struct = array_struct,
                    .type_enum = ARRAY
                };
                
                shput(parsed_structs->structs, type_name, type_data);

                return true;
            }
        }

        // Validates if struct has no pointer fields
        for(int i = 0; i < arrlen(fields); i++)
        {
            if(fields[i].is_pointer && !fields[i].is_string)
            {
                error = "Invalid struct definition with pointer fields";
                return false;
            }
        }

        TypeStruct object_struct = {
            .fields = fields,
            .type = type,
            .type_name = type_name
        };

        TypeData type_data = {
            .type_struct = object_struct,
            .type_enum = OBJECT
        };

        shput(parsed_structs->structs, type_name, type_data);

        return true;
    }

    sprintf((char *)error, "Invalid struct definition starting with %s", curr_type);
    return false;
}

void struct_match_handler(void *user_data, const char *source_code, TSQuery *query, TSQueryMatch match)
{
    ParsedStructs *parsed_structs = (ParsedStructs *)user_data;

    for (unsigned i = 0; i < match.capture_count; i++)
    {
        TSQueryCapture capture = match.captures[i];

        char error[256];
        if(!parse_struct(capture.node, source_code, parsed_structs, error))
        {
            perror(error);
        }
    }
}

void parse_structs(const char *source_code, ParseResult *parse_result, const char *file)
{
    // Initialize Tree-sitter
    TSParser *parser = ts_parser_new();
    ts_parser_set_language(parser, tree_sitter_c());
    TSTree *tree = ts_parser_parse_string(parser, NULL, source_code, strlen(source_code));

    ParsedStructs parsed_structs = {0};

    sh_new_arena(parsed_structs.structs);

    if(run_query_from_file(&parsed_structs.structs, "queries\\generate_parser.query", source_code, ts_tree_root_node(tree), struct_match_handler))
    {
        shput(parse_result->files, file, parsed_structs);
    }

    ts_tree_delete(tree);
    ts_parser_delete(parser);
}

void process_file(const char *absolute_path, const char *relative_path, ParseResult *parse_result)
{
    const char *content = load_text_file(absolute_path);

    parse_structs(content, parse_result, relative_path);
    
    free((char *)content);
}

void handle_header_file(const char *root_path, const char *file_path, void *user_data)
{
    ParseResult *parse_result = (ParseResult *)user_data;

    const char *ext = strrchr(file_path, '.');

    if (ext != NULL && strcmp(ext, ".h") == 0)
    {
        process_file(root_path, file_path, parse_result);
    }
}

void parse_headers(const char *path, ParseResult *parse_result)
{
    platform_traverse_directory_recursively(path, handle_header_file, parse_result);
}